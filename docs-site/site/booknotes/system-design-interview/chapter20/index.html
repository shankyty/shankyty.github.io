
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://example.com/booknotes/system-design-interview/chapter20/">
      
      
        <link rel="prev" href="../chapter19/">
      
      
        <link rel="next" href="../chapter21/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.19">
    
    
      
        <title>Distributed Message Queue - Notes</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#distributed-message-queue" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Notes" class="md-header__button md-logo" aria-label="Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Distributed Message Queue
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Notes" class="md-nav__button md-logo" aria-label="Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Welcome to My Notes
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Booknotes
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Booknotes
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    System design
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            System design
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../system-design/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    System Design
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_2" >
        
          
          <label class="md-nav__link" for="__nav_2_1_2" id="__nav_2_1_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Understanding distributed systems
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_2">
            <span class="md-nav__icon md-icon"></span>
            Understanding distributed systems
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../system-design/understanding-distributed-systems/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Index
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../system-design/understanding-distributed-systems/part00/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Introduction
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../system-design/understanding-distributed-systems/part01/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Communication
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../system-design/understanding-distributed-systems/part02/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Coordination
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../system-design/understanding-distributed-systems/part03/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Scalability
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../system-design/understanding-distributed-systems/part04/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Resiliency
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../system-design/understanding-distributed-systems/part05/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Maintainability
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    System design interview
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            System design interview
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    System Design Interview - An Insider's Guide (vol 1 &amp; 2)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter02/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Scale From Zero to Millions of Users
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter03/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Back-of-the-envelope Estimation
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter04/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    A Framework for System Design Interviews
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter05/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design a Rate Limiter
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter06/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design Consistent Hashing
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter07/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design a Key-Value Store
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter08/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design a Unique ID Generator in Distributed Systems
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter09/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design a URL Shortener
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter10/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design a Web Crawler
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter11/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design a Notification System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter12/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design a News Feed System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter13/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design a Chat System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter14/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design A Search Autocomplete System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter15/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design YouTube
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter16/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design Google Drive
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter17/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Proximity Service
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter18/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Nearby Friends
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter19/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Google Maps
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Distributed Message Queue
    
  </span>
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter21/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Metrics Monitoring and Alerting System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter22/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Ad Click Event Aggregation
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter23/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Hotel Reservation System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter24/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Distributed Email Service
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter25/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    S3-like Object Storage
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter26/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Real-time Gaming Leaderboard
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter27/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Payment System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter28/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Digital Wallet
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Stock Exchange
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="distributed-message-queue">Distributed Message Queue</h1>
<p>We'll be designing a distributed message queue in this chapter.</p>
<p>Benefits of message queues:
 * Decoupling - Eliminates tight coupling between components. Let them update separately.
 * Improved scalability - Producers and consumers can be scaled independently based on traffic.
 * Increased availability - If one part of the system goes down, other parts continue interacting with the queue.
 * Better performance - Producers can produce messages without waiting for consumer confirmation.</p>
<p>Some popular message queue implementations - Kafka, RabbitMQ, RocketMQ, Apache Pulsar, ActiveMQ, ZeroMQ.</p>
<p>Strictly speaking, Kafka and Pulsar are not message queues. They are event streaming platforms.
There is however a convergence of features which blurs the distinction between message queues and event streaming platforms.</p>
<p>In this chapter, we'll be building a message queue with support for more advanced features such as long data retention, repeated message consumption, etc.</p>
<h1 id="step-1-understand-the-problem-and-establish-design-scope">Step 1 - Understand the problem and establish design scope</h1>
<p>Message queues ought to support few basic features - producers produce messages and consumers consume them.
There are, however, different considerations with regards to performance, message delivery, data retention, etc.</p>
<p>Here's a set of potential questions between Candidate and Interviewer:
 * C: What's the format and average message size? Is it text only?
 * I: Messages are text-only and usually a few KBs
 * C: Can messages be repeatedly consumed?
 * I: Yes, messages can be repeatedly consumed by different consumers. This is an added requirement, which traditional message queues don't support.
 * C: Are messages consumed in the same order they were produced?
 * I: Yes, order guarantee should be preserved. This is an added requirement, traditional message queues don't support this.
 * C: What are the data retention requirements?
 * I: Messages need to have a retention of two weeks. This is an added requirement.
 * C: How many producers and consumers do we want to support?
 * I: The more, the better.
 * C: What data delivery semantic do we want to support? At-most-once, at-least-once, exactly-once?
 * I: We definitely want to support at-least-once. Ideally, we can support all and make them configurable.
 * C: What's the target throughput for end-to-end latency?
 * I: It should support high throughput for use cases like log aggregation and low throughput for more traditional use cases.</p>
<p>Functional requirements:
 * Producers send messages to a message queue
 * Consumers consume messages from the queue
 * Messages can be consumed once or repeatedly
 * Historical data can be truncated
 * Message size is in the KB range
 * Order of messages needs to be preserved
 * Data delivery semantics is configurable - at-most-once/at-least-once/exactly-once.</p>
<p>Non-functional requirements:
 * High throughput or low latency. Configurable based on use-case
 * Scalable - system should be distributed and support a sudden surge in message volume
 * Persistent and durable - data should be persisted on disk and replicated among nodes</p>
<p>Traditional message queues typically don't support data retention and don't provide ordering guarantees. This greatly simplifies the design and we'll discuss it.</p>
<h1 id="step-2-propose-high-level-design-and-get-buy-in">Step 2 - Propose high-level design and get buy-in</h1>
<p>Key components of a message queue:
<img alt="message-queue-components" src="images/message-queue-components.png" />
 * Producer sends messages to a queue
 * Consumer subscribes to a queue and consumes the subscribed messages
 * Message queue is a service in the middle which decouples producers from consumers, letting them scale independently.
 * Producer and consumer are both clients, while the message queue is the server.</p>
<h2 id="messaging-models">Messaging models</h2>
<p>The first type of messaging model is point-to-point and it's commonly found in traditional message queues:
<img alt="point-to-point-model" src="images/point-to-point-model.png" />
 * A message is sent to a queue and it's consumed by exactly one consumer.
 * There can be multiple consumers, but a message is consumed only once.
 * Once message is acknowledged as consumed, it is removed from the queue.
 * There is no data retention in the point-to-point model, but there is such in our design.</p>
<p>On the other hand, the publish-subscribe model is more common for event streaming platforms:
<img alt="publish-subscribe-model" src="images/publish-subscribe-model.png" />
 * In this model, messages are associated to a topic.
 * Consumers are subscribed to a topic and they receive all messages sent to this topic.</p>
<h2 id="topics-partitions-and-brokers">Topics, partitions and brokers</h2>
<p>What if the data volume for a topic is too large? One way to scale is by splitting a topic into partitions (aka sharding):
<img alt="partitions" src="images/partitions.png" />
 * Messages sent to a topic are evenly distributed across partitions
 * The servers that host partitions are called brokers
 * Each topic operates like a queue using FIFO for message processing. Message order is preserved within a partition.
 * The position of a message within the partition is called an <strong>offset</strong>.
 * Each message produced is sent to a specific partition. A partition key specifies which partition a message should land in. 
   * Eg a <code>user_id</code> can be used as a partition key to guarantee order of messages for the same user.
 * Each consumer subscribes to one or more partitions. When there are multiple consumers for the same messages, they form a consumer group.</p>
<h2 id="consumer-groups">Consumer groups</h2>
<p>Consumer groups are a set of consumers working together to consume messages from a topic:
<img alt="consumer-groups" src="images/consumer-groups.png" />
 * Messages are replicated per consumer group (not per consumer).
 * Each consumer group maintains its own offset.
 * Reading messages in parallel by a consumer group improves throughput but hampers the ordering guarantee.
 * This can be mitigated by only allowing one consumer from a group to be subscribed to a partition. 
 * This means that we can't have more consumers in a group than there are partitions.</p>
<h2 id="high-level-architecture">High-level architecture</h2>
<p><img alt="high-level-architecture" src="images/high-level-architecture.png" />
 * Clients are producer and consumer. Producer pushes messages to a designated topic. Consumer group subscribes to messages from a topic.
 * Brokers hold multiple partitions. A partition holds a subset of messages for a topic.
 * Data storage stores messages in partitions.
 * State storage keeps the consumer states.
 * Metadata storage stores configuration and topic properties
 * The coordination service is responsible for service discovery (which brokers are alive) and leader election (which broker is leader, responsible for assigning partitions).</p>
<h1 id="step-3-design-deep-dive">Step 3 - Design Deep Dive</h1>
<p>In order to achieve high throughput and preserve the high data retention requirement, we made some important design choices:
 * We chose an on-disk data structure which takes advantage of the properties of modern HDD and disk caching strategies of modern OS-es.
 * The message data structure is immutable to avoid extra copying, which we want to avoid in a high volume/high traffic system.
 * We designed our writes around batching as small I/O is an enemy of high throughput.</p>
<h2 id="data-storage">Data storage</h2>
<p>In order to find the best data store for messages, we must examine a message's properties:
 * Write-heavy, read-heavy
 * No update/delete operations. In traditional message queues, there is a "delete" operation as messages are not retained.
 * Predominantly sequential read/write access pattern.</p>
<p>What are our options:
 * Database - not ideal as typical databases don't support well both write and read heavy systems.
 * Write-ahead log (WAL) - a plain text file which only supports appending to it and is very HDD-friendly. 
   * We split partitions into segments to avoid maintaining a very large file.
   * Old segments are read-only. Writes are accepted by latest segment only.
<img alt="wal-example" src="images/wal-example.png" /></p>
<p>WAL files are extremely efficient when used with traditional HDDs. </p>
<p>There is a misconception that HDD acces is slow, but that hugely depends on the access pattern.
When the access pattern is sequential (as in our case), HDDs can achieve several MB/s write/read speed which is sufficient for our needs.
We also piggyback on the fact that the OS caches disk data in memory aggressively.</p>
<h2 id="message-data-structure">Message data structure</h2>
<p>It is important that the message schema is compliant between producer, queue and consumer to avoid extra copying. This allows much more efficient processing.</p>
<p>Example message structure:
<img alt="message-structure" src="images/message-structure.png" /></p>
<p>The key of the message specifies which partition a message belongs to. An example mapping is <code>hash(key) % numPartitions</code>.
For more flexibility, the producer can override default keys in order to control which partitions messages are distributed to.</p>
<p>The message value is the payload of a message. It can be plaintext or a compressed binary block.</p>
<p><strong>Note:</strong> Message keys, unlike traditional KV stores, need not be unique. It is acceptable to have duplicate keys and for it to even be missing.</p>
<p>Other message files:
 * Topic - topic the message belongs to
 * Partition - The ID of the partition a message belongs to
 * Offset - The position of the message in a partition. A message can be located via <code>topic</code>, <code>partition</code>, <code>offset</code>.
 * Timestamp - When the message is stored
 * Size - the size of this message
 * CRC - checksum to ensure message integrity</p>
<p>Additional features such as filtering can be supported by adding additional fields.</p>
<h2 id="batching">Batching</h2>
<p>Batching is critical for the performance of our system. We apply it in the producer, consumer and message queue.</p>
<p>It is critical because:
 * It allows the operating system to group messages together, amortizing the cost of expensive network round trips
 * Messages are written to the WAL in groups sequentially, which leads to a lot of sequential writes and disk caching.</p>
<p>There is a trade-off between latency and throughput:
 * High batching leads to high throughput and higher latency. 
 * Less batching leads to lower throughput and lower latency.</p>
<p>If we need to support lower latency since the system is deployed as a traditional message queue, the system could be tuned to use a smaller batch size.</p>
<p>If tuned for throughput, we might need more partitions per topic to compensate for the slower sequential disk write throughput.</p>
<h2 id="producer-flow">Producer flow</h2>
<p>If a producer wants to send a message to a partition, which broker should it connect to?</p>
<p>One option is to introduce a routing layer, which route messages to the correct broker. If replication is enabled, the correct broker is the leader replica:
<img alt="routing-layer" src="images/routing-layer.png" />
 * Routing layer reads the replication plan from the metadata store and caches it locally.
 * Producer sends a message to the routing layer.
 * Message is forwarded to broker 1 who is the leader of the given partition
 * Follower replicas pull the new message from the leader. Once enough confirmations are received, the leader commits the data and responds to the producer.</p>
<p>The reason for having replicas is to enable fault tolerance.</p>
<p>This approach works but has some drawbacks:
 * Additional network hops due to the extra component
 * The design doesn't enable batching messages</p>
<p>To mitigate these issues, we can embed the routing layer into the producer:
<img alt="routing-layer-producer" src="images/routing-layer-producer.png" />
 * Fewer network hops lead to lower latency
 * Producers can control which partition a message is routed to
 * The buffer allows us to batch messages in-memory and send out larger batches in a single request, which increases throughput.</p>
<p>The batch size choice is a classical trade-off between throughput and latency. 
<img alt="batch-size-throughput-vs-latency" src="images/batch-size-throughput-vs-latency.png" />
 * Larger batch size leads to longer wait time before batch is committed. 
 * Smaller batch size leads to request being sent sooner and having lower latency but lower throughput.</p>
<h2 id="consumer-flow">Consumer flow</h2>
<p>The consumer specifies its offset in a partition and receives a chunk of messages, beginning from that offset:
<img alt="consumer-example" src="images/consumer-example.png" /></p>
<p>One important consideration when designing the consumer is whether to use a push or a pull model:
 * Push model leads to lower latency as broker pushes messages to consumer as it receives them.
   * However, if rate of consumption falls behind the rate of production, the consumer can be overwhelmed.
   * It is challenging to deal with consumers with varying processing power as the broker controls the rate of consumption.
 * Pull model leads to the consumer controlling the consumption rate. 
   * If rate of consumption is slow, consumer will not be overwhelmed and we can scale it to catch up.
   * The pull model is more suitable for batch processing, because with the push model, the broker can't know how many messages a consumer can handle. 
   * With the pull model, on the other hand, consumers can aggressively fetch large message batches.
   * The down side is the higher latency and extra network calls when there are no new messages. Latter issue can be mitigated using long polling.</p>
<p>Hence, most message queues (and us) choose the pull model.
<img alt="consumer-flow" src="images/consumer-flow.png" />
 * A new consumer subscribes to topic A and joins group 1.
 * The correct broker node is found by hashing the group name. This way, all consumers in a group connect to the same broker.
 * Note that this consumer group coordinator is different from the coordination service (ZooKeeper).
 * Coordinator confirms that the consumer has joined the group and assigns partition 2 to that consumer.
 * There are different partition assignment strategies - round-robin, range, etc.
 * Consumer fetches latest messages from the last offset. The state storage keeps the consumer offsets.
 * Consumer processes messages and commits the offset to the broker. The order of those operations affects the message delivery semantics.</p>
<h2 id="consumer-rebalancing">Consumer rebalancing</h2>
<p>Consumer rebalancing is responsible for deciding which consumers are responsible for which partition.</p>
<p>This process occurs when a consumer joins/leaves or a partition is added/removed.</p>
<p>The broker, acting as a coordinator plays a huge role in orchestrating the rebalancing workflow.
<img alt="consumer-rebalancing" src="images/consumer-rebalancing.png" />
 * All consumers from the same group are connected to the same coordinator. The coordinator is found by hashing the group name.
 * When the consumer list changes, the coordinator chooses a new leader of the group.
 * The leader of the group calculates a new partition dispatch plan and reports it back to the coordinator, which broadcasts it to the other consumers.</p>
<p>When the coordinator stops receiving heartbeats from the consumers in a group, a rebalancing is triggered:
<img alt="consumer-rebalance-example" src="images/consumer-rebalance-example.png" /></p>
<p>Let's explore what happens when a consumer joins a group:
<img alt="consumer-join-group-usecase" src="images/consumer-join-group-usecase.png" />
 * Initially, only consumer A is in the group and it consumes all partitions.
 * Consumer B sends a request to join the group.
 * The coordinator notifies all group members that it's time to rebalance passively - as a response to the heartbeat.
 * Once all consumers rejoin the group, the coordinator chooses a leader and notifies the rest about the election result.
 * The leader generates the partition dispatch plan and sends it to the coordinator. Others wait for the dispatch plan.
 * Consumers start consuming from the newly assigned partitions.</p>
<p>Here's what happens when a consumer leaves the group:
<img alt="consumer-leaves-group-usecase" src="images/consumer-leaves-group-usecase.png" />
 * Consumer A and B are in the same group
 * Consumer B asks to leave the group
 * When coordinator receives A's heartbeat, it informs them that it's time to rebalance.
 * The rest of the steps are the same.</p>
<p>The process is similar when a consumer doesn't send a heartbeat for a long time:
<img alt="consumer-no-heartbeat-usecase" src="images/consumer-no-heartbeat-usecase.png" /></p>
<h2 id="state-storage">State storage</h2>
<p>The state storage stores mapping between partitions and consumers, as well as the last consumed offsets for a partition.
<img alt="state-storage" src="images/state-storage.png" /></p>
<p>Group 1's offset is at 6, meaning all previous messages are consumed. If a consumer crashes, the new consumer will continue from that message on wards.</p>
<p>Data access patterns for consumer states:
 * Frequent read/write operations, but low volume
 * Data is updated frequently, but rarely deleted
 * Random read/write
 * Data consistency is important</p>
<p>Given these requirements, a fast KV storage like Zookeeper is ideal.</p>
<h2 id="metadata-storage">Metadata storage</h2>
<p>The metadata storage stores configuration and topic properties - partition number, retention period, replica distribution.</p>
<p>Metadata doesn't change often and volume is small, but there is a high consistency requirement.
Zookeeper is a good choice for this storage.</p>
<h2 id="zookeeper">ZooKeeper</h2>
<p>Zookeeper is essential for building distributed message queues.</p>
<p>It is a hierarchical key-value store, commonly used for a distributed configuration, synchronization service and naming registry (ie service discovery).
<img alt="zookeeper" src="images/zookeeper.png" /></p>
<p>With this change, the broker only needs to maintain data for the messages. Metadata and state storage is in Zookeeper.</p>
<p>Zookeeper also helps with leader election of the broker replicas.</p>
<h2 id="replication">Replication</h2>
<p>In distributed systems, hardware issues are inevitable. We can tackle this via replication to achieve high availability.
<img alt="replication-example" src="images/replication-example.png" />
 * Each partition is replicated across multiple brokers, but there is only one leader replica.
 * Producers send messages to leader replicas
 * Followers pull the replicated messages from the leader
 * Once enough replicas are synchronized, the leader returns acknowledgment to the producer
 * Distribution of replicas for each partition is called the replica distribution plan.
 * The leader for a given partition creates the replica distribution plan and saves it in Zookeeper</p>
<h2 id="in-sync-replicas">In-sync replicas</h2>
<p>One problem we need to tackle is keeping messages in-sync between the leader and the followers for a given partition.</p>
<p>In-sync replicas (ISR) are replicas for a partition that stay in-sync with the leader.</p>
<p>The <code>replica.lag.max.messages</code> defines how many messages can a replica be lagging behind the leader to be considered in-sync.</p>
<p><img alt="in-sync-replicas-example" src="images/in-sync-replicas-example.png" />
 * Committed offset is 13
 * Two new messages are written to the leader, but not committed yet.
 * A message is committed once all replicas in the ISR have synchronized that message
 * Replica 2 and 3 have fully caught up with leader, hence, they are in ISR
 * Replica 4 has lagged behind, hence, is removed from ISR for now</p>
<p>ISR reflects a trade-off between performance and durability.
 * In order for producers not to lose messages, all replicas should be in sync before sending an acknowledgment
 * But a slow replica will cause the whole partition to become unavailable</p>
<p>Acknowledgment handling is configurable.</p>
<p><code>ACK=all</code> means that all replicas in ISR have to sync a message. Message sending is slow, but message durability is highest.
<img alt="ack-all" src="images/ack-all.png" /></p>
<p><code>ACK=1</code> means that producer receives acknowledgment once leader receives the message. Message sending is fast, but message durability is low.
<img alt="ack-1" src="images/ack-1.png" /></p>
<p><code>ACK=0</code> means that producer sends messages without waiting for any acknowledgment from leader. Message sending is fastest, message durability is lowest.
<img alt="ack-0" src="images/ack-0.png" /></p>
<p>On the consumer side, we can connect all consumers to the leader for a partition and let them read messages from it:
 * This makes for the simplest design and easiest operation
 * Messages in a partition are sent to only one consumer in a group, which limits the connections to the leader replica
 * The number of connections to leader replica is typically not high as long as the topic is not super hot
 * We can scale a hot topic by increasing the number of partitions and consumers
 * In certain scenarios, it might make sense to let a consumer lead from an ISR, eg if they're located in a separate DC</p>
<p>The ISR list is maintained by the leader who tracks the lag between itself and each replica.</p>
<h2 id="scalability">Scalability</h2>
<p>Let's evaluate how we can scale different parts of the system.</p>
<h3 id="producer">Producer</h3>
<p>The producer is much smaller than the consumer. Its scalability can easily be achieved by adding/removing new producer instances.</p>
<h3 id="consumer">Consumer</h3>
<p>Consumer groups are isolated from each other. It is easy to add/remove consumer groups at will.</p>
<p>Rebalancing help handle the case when consumers are added/removed from a group gracefully.</p>
<p>Consumer groups are rebalancing help us achieve scalability and fault tolerance.</p>
<h3 id="broker">Broker</h3>
<p>How do brokers handle failure?
<img alt="broker-failure-recovery" src="images/broker-failure-recovery.png" />
 * Once a broker fails, there are still enough replicas to avoid partition data loss
 * A new leader is elected and the broker coordinator redistributes partitions which were at the failed broker to existing replicas
 * Existing replicas pick up the new partitions and act as followers until they're caught up with the leader and become ISR</p>
<p>Additional considerations to make the broker fault-tolerant:
 * The minimum number of ISRs balances latency and safety. You can fine-tune it to meet your needs.
 * If all replicas of a partition are in the same node, then it's a waste of resources. Replicas should be across different brokers.
 * If all replicas of a partition crash, then the data is lost forever. Spreading replicas across data centers can help, but it adds up a lot of latency. One option is to use <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=27846330">data mirroring</a> as a work around.</p>
<p>How do we handle redistribution of replicas when a new broker is added?
<img alt="broker-replica-redistribution" src="images/broker-replica-redistribution.png" />
 * We can temporarily allow more replicas than configured, until new broker catches up
 * Once it does, we can remove the partition replica which is no longer needed</p>
<h3 id="partition">Partition</h3>
<p>Whenever a new partition is added, the producer is notified and consumer rebalancing is triggered.</p>
<p>In terms of data storage, we can only store new messages to the new partition vs. trying to copy all old ones:
<img alt="partition-exmaple" src="images/partition-exmaple.png" /></p>
<p>Decreasing the number of partitions is more involved:
<img alt="partition-decrease" src="images/partition-decrease.png" />
 * Once a partition is decommissioned, new messages are only received by remaining partitions
 * The decommissioned partition isn't removed immediately as messages can still be consumed from it
 * Once a pre-configured retention period passes, do we truncate the data and storage space is freed up
 * During the transitional period, producers only send messages to active partitions, but consumers read from all
 * Once retention period expires, consumers are rebalanced</p>
<h2 id="data-delivery-semantics">Data delivery semantics</h2>
<p>Let's discuss different delivery semantics.</p>
<h3 id="at-most-once">At-most once</h3>
<p>With this guarantee, messages are delivered not more than once and could not be delivered at all.
<img alt="at-most-once" src="images/at-most-once.png" />
 * Producer sends a message asynchronously to a topic. If message delivery fails, there is no retry.
 * Consumer fetches message and immediately commits offset. If consumer crashes before processing the message, the message will not be processed.</p>
<h3 id="at-least-once">At-least once</h3>
<p>A message can be sent more than once and no message should be left unprocessed.
<img alt="at-least-once" src="images/at-least-once.png" />
 * Producer sends message with <code>ack=1</code> or <code>ack=all</code>. If there is any issue, it will keep retrying.
 * Consumer fetches the message and consumes the offset only after it's done processing it.
 * It is possible for a message to be delivered more than once if eg consumer crashes before committing offset but after processing it.
 * This is why, this is good for use-cases where data duplication is acceptable or deduplication is possible.</p>
<h3 id="exactly-once">Exactly once</h3>
<p>Extremely costly to implement for the system, albeit it's the friendliest guarantee to users:
<img alt="exactly-once" src="images/exactly-once.png" /></p>
<h2 id="advanced-features">Advanced features</h2>
<p>Let's discuss some advanced features, we might discuss in the interview.</p>
<h3 id="message-filtering">Message filtering</h3>
<p>Some consumers might want to only consume messages of a certain type within a partition.</p>
<p>This can be achieved by building separate topics for each subset of messages, but this can be costly if systems have too many differing use-cases.
 * It is a waste of resources to store the same message on different topics
 * Producer is now tightly coupled to consumers as it changes with each new consumer requirement</p>
<p>We can resolve this using message filtering.
 * A naive approach would be to do the filtering on the consumer-side, but that introduces unnecessary consumer traffic
 * Alternatively, messages can have tags attached to them and consumers can specify which tags they're subscribed to
 * Filtering could also be done via the message payloads but that can be challenging and unsafe for encrypted/serialized messages
 * For more complex mathematical formulaes, the broker could implement a grammar parser or script executor, but that can be heavyweight for the message queue
<img alt="message-filtering" src="images/message-filtering.png" /></p>
<h3 id="delayed-messages-scheduled-messages">Delayed messages &amp; scheduled messages</h3>
<p>For some use-cases, we might want to delay or schedule message delivery. 
For example, we might submit a payment verification check for 30m from now, which triggers the consumer to see if a payment was successful.</p>
<p>This can be achieved by sending messages to temporary storage in the broker and moving the message to the partition at the right time:
<img alt="delayed-message-implementation" src="images/delayed-message-implementation.png" />
 * The temporary storage can be one or more special message topics
 * The timing function can be achieved using dedicated delay queues or a <a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf">hierarchical time wheel</a></p>
<h1 id="step-4-wrap-up">Step 4 - Wrap up</h1>
<p>Additional talking points:
 * Protocol of communication. Important considerations - support all use-cases and high data volume, as well as verify message integrity. Popular protocols - AMQP and Kafka protocol.
 * Retry consumption - if we can't process a message immediately, we could send it to a dedicated retry topic to be attempted later.
 * Historical data archive - old messages can be backed up in high-capacity storages such as HDFS or object storage (eg S3).</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.92b07e13.min.js"></script>
      
    
  </body>
</html>